<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>初识分布式事务</title>
      <link href="2021/03/22/%E5%88%9D%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>2021/03/22/%E5%88%9D%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="前置概念了解"><a href="#前置概念了解" class="headerlink" title="前置概念了解"></a>前置概念了解</h1><h2 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h2><p>事务是一组操作组成的一个操作序列, 当所有的操作都正常执行之后才能被全部提交. 只要有任意一次的操作失败了, 都将回滚所有的操作.</p><p>简单的说就是, 要么全部做完, 要么一个都别做.</p><h2 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h2><p>A(Atomicity)原子性</p><p>C(Consistency)一致性</p><p>I(Isolation)隔离性</p><p>D(Durability)持久性</p><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>CAP是2000年在PODC上提出的一个猜想. 2002年在MIT被证明. (证明是严格的证明, 讨论了在两个互相矛盾的请求到达彼此连接不通的两个不同的分布式节点)</p><ul><li>一致性（Consistency） </li><li>可用性（Availability）</li><li>分区容错性（Partition tolerance）</li></ul><h2 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h2><p>经过了长时间的实践, 人们发现通过CAP定理来维护事物的ACID特性需要付出很大的特性, 总结出来一套弱化的事务特性. 服务化中，更多的是提升 A 以及 P，在这个过程中不可避免的会降低对 C 的要求</p><ul><li>基本可用（Basically Available）：系统能够基本运行、一直提供服务。</li><li>软状态（Soft-state）：系统不要求一直保持强一致状态。</li><li>最终一致性（Eventual consistency）：系统需要在某一时刻后达到一致性要求。</li></ul><h1 id="分布式事务产生场景"><a href="#分布式事务产生场景" class="headerlink" title="分布式事务产生场景"></a>分布式事务产生场景</h1><p>随着互联网的发展, 简单的单机提供单一服务已经不能满足当下需求. </p><p>随着大数据时代来临, 庞大的数据量单一数据库已经不能完成很好的服务.</p><p>一个业务功能可能需要跨越多个服务和操作多个数据库. 分布式事务就是为了保证不同服务器之间的数据一致性.</p><h2 id="数据库分库"><a href="#数据库分库" class="headerlink" title="数据库分库"></a>数据库分库</h2><p>一个数据对应多个数据库</p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>一个业务跨越多个服务, 同时操作多个数据库</p><h1 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h1><h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>这是最简单的分布式事务解决方案, 也是其他解决方案的<strong>基础思维</strong>.</p><p>两个角色: 协调者(TM Transaction Manager), 参与者(RM Resource Manager)</p><h3 id="投票阶段"><a href="#投票阶段" class="headerlink" title="投票阶段"></a>投票阶段</h3><p>TM通知各RM准备提交事务.</p><ul><li>如果RM可以提交事务则给TM回复确定</li><li>如果RM无法提交则回复否定</li></ul><h3 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h3><p>TM根据所有RM的结果决定是提交还是回滚事务.</p><ul><li>如果全部为确认响应, 发起提交请求, RM收到请求后提交事务.</li><li>如果有否定响应, 则发起回滚请求, RM收到请求后回滚事务.</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>尽量高效的确保了数据的强一致性, 但不是100%一致.</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>TM故障: RM会一直阻塞, 事务资源被锁定, 无法继续完成事务操作和后续操作.</li><li>同步阻塞: 在等待TM回复的过程中一直占用公共资源, 导致第三方访问公共资源阻塞.</li><li>数据不一致: <ul><li>提交阶段TM发起提交请求后, 出现网络异常导致部分RM无法收到请求, 产生不一致数据.</li><li>如果协调者在第二阶段发送提交请求之后挂掉，而唯一接受到这条消息的参与者执行之后也挂掉了，即使协调者通过选举协议产生了新的协调者并通知其他参与者进行提交或回滚操作的话，都可能会与这个已经执行的参与者执行的操作不一样。</li></ul></li></ul><h2 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h2><h3 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h3><ol><li>引入超时机制.</li><li>新增一个阶段解决由于TM故障引起的阻塞问题.</li></ol><h3 id="第一阶段-CanCommit"><a href="#第一阶段-CanCommit" class="headerlink" title="第一阶段 CanCommit"></a>第一阶段 CanCommit</h3><p>等同于<strong>2PC</strong>的投票阶段</p><h3 id="第二阶段-PreCommit"><a href="#第二阶段-PreCommit" class="headerlink" title="第二阶段 PreCommit"></a>第二阶段 PreCommit</h3><p>TM判断各RM的响应轻快判断是否做预提交操作(PreCommit), 有两种可能:</p><ul><li><p>如果所有RM返回确认响应, 执行事务预提交</p><ol><li>向所有RM发送<code>PreCommit</code>请求</li><li>RM收到后将事务操作写入事务日志, 进行事务操作持久化.</li><li>成功完成了事务操作持久化后, 给TM确认响应, 等待下一步指令</li></ol></li><li><p>假如有RM返回了否认响应, 或者TM等待超时, 执行中断请求.</p><ol><li>TM向所有RM发送Abort请求.</li><li>RM收到Abort请求后执行事务中断.</li></ol></li></ul><h3 id="第三阶段-DoCommit"><a href="#第三阶段-DoCommit" class="headerlink" title="第三阶段 DoCommit"></a>第三阶段 DoCommit</h3><p>进行真正的事务提交</p><ul><li>执行提交<ol><li>TM收到所有RM来自PreCommit阶段的确认响应后,将状态更改为(预提交-&gt;)提交, 向所有RM发送确认提交请求.</li><li>RM收到确认提交请求后提交事务并释放事务资源.</li><li>RM完成后向TM发送确认请求.</li><li>TM收到所有RM在DoCommit阶段的确认后, 确认事务完成.</li></ol></li><li>中断事务<ol><li>TM没有收到所有RM来自PreCommit阶段的确认响应, (或是收到了RM的超时响应) (或者自身超时), 向所有的RM发送Abort请求.</li><li>RM收到Abort请求后, 根据事务操作日志中的记录回滚事务并释放事务资源.</li><li>RM完成回滚后, 向TM发送回滚完成确认响应.</li><li>TM收到RM的回滚确认后, 确认事务中断.</li></ol></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>已经解决了<ol><li>由于TM和某些RM挂掉导致的数据一致性问题</li><li>TM单点故障问题</li></ol></li><li>但是仍然存在<ol><li>在DoCommit阶段如果TM执行事务中断, 部分RM未能收到请求默认执行事务提交而导致的数据一致性问题.</li></ol></li></ul><p>可见2PC和3PC都无法保证100%数据一致性.</p><hr><p>简单写了一些, 明日再更.</p><p>先写作业，难顶</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> 算法 </category>
          
          <category> 分布式系统 </category>
          
          <category> 分布式事务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
