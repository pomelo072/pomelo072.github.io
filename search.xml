<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OS学习_6.S081介绍</title>
      <link href="2021/04/23/OS%E5%AD%A6%E4%B9%A0-6-S081%E4%BB%8B%E7%BB%8D/"/>
      <url>2021/04/23/OS%E5%AD%A6%E4%B9%A0-6-S081%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction-and-Examples"><a href="#Introduction-and-Examples" class="headerlink" title="Introduction and Examples"></a>Introduction and Examples</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>理解操作系统的设计和实现. 设计是指整体的系统结构, 实现是指具体的代码设计</li><li>了解操作系统工作原理, 动手实现OS, 并通过操作系统的接口, 编写系统软件.</li></ol><h2 id="操作系统本身的目标"><a href="#操作系统本身的目标" class="headerlink" title="操作系统本身的目标"></a>操作系统本身的目标</h2><ol><li>抽象硬件. 硬件本身是较低层次的资源, 操作系统<strong>实现了高层次的接口和抽象</strong>, 像进程(Process),文件系统(file System)等, 为其他硬件提供了一个基本的环境, 也提供了更好的移植性.</li><li>其次是使得多个的应用之间能够共享计算机底层的硬件资源. 我们能够在计算机上同时运行多个应用而他们之间不会相互影响, 这叫<strong>多路复用 (multiplex)</strong>.</li><li>在多路复用下我们要保证这些程序不会相互影响, 需要<strong>隔离(Isolation)</strong>.</li><li>但是我们也需要一些有用的影响, 我们需要能够<strong>共享(Sharing)</strong>. 例如像数据交互, 进程通信等.</li><li>用户想要能够自主控制是否共享, 我们需要一个<strong>权限系统(Security / Access Control System)</strong>.</li><li>在确保操作系统自身服务正常运行的情况下, 能为应用提供<strong>高性能(Performance)</strong>, 且OS不能阻碍应用获取高的性能, 甚至需要帮助应用获得高性能.</li><li>一个操作系统需要能够<strong>满足不同用户的不同需求</strong>, 支持很多不同类型的应用. 可以打游戏, 写文档, 还能运行数据库服务.</li></ol><h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><table><thead><tr><th>应用</th><th>编译器</th><th>Shell</th><th>DB</th></tr></thead><tbody><tr><td>文件系统</td><td>进程管理</td><td>内存分配</td><td>访问控制</td></tr><tr><td>CPU</td><td>内存</td><td>硬盘</td><td>网络接口</td></tr></tbody></table><p>底层是计算机硬件. 整个计算机共用这些硬件资源</p><p>中间是内核服务, 用来管理控制计算机的资源, 同时管理用户进程, 操作系统的核心.</p><p>顶层是用户的应用.</p><p>操作系统主要研究系统的内核, 连接内核和应用之间的接口, 内核服务的架构.</p><h3 id="Kernel-API"><a href="#Kernel-API" class="headerlink" title="Kernel API"></a>Kernel API</h3><p>类似于程序的函数调用, 是向内核发起系统调用, 使得应用能够访问内核中的服务.</p><p>与函数调用不同的是, 系统调用会跳到内核中进行.</p><p>内核是在计算机启动时第一个运行的, 且始终在运行着. 内核拥有操作硬件的权限, 执行系统调用就能跳到内核中操作硬件, 而程序中的函数调用做不到这点.</p><h2 id="困难与乐趣并存"><a href="#困难与乐趣并存" class="headerlink" title="困难与乐趣并存"></a>困难与乐趣并存</h2><h3 id="矛盾点"><a href="#矛盾点" class="headerlink" title="矛盾点"></a>矛盾点</h3><p>在设计操作系统时会遇到许多矛盾点.</p><ol><li>我们希望操作系统是高效且易用的.<ul><li>高效意味着我们需要在设计上更贴近硬件底层一些</li><li>易用则需要OS为应用提供可移植的抽象接口.</li><li>需要在两者中达成一个平衡.</li></ul></li><li>而在给其他人在你的OS上开发时, 你希望能够给其他程序员更简单易用的API来调取内核服务.<ul><li>接口不能太多太复杂.</li><li>接口要有强大的功能 (我理解为很实用的, 功能齐全的)</li><li>我们需要提供出简单但是又强大的接口</li></ul></li><li>最后一个矛盾是, 想要OS能给应用更多的灵活性, 同时要保证安全性.<ul><li>应用不能跳过内核直接访问到硬件影响其他应用, 或是影响操作系统.</li></ul></li></ol><table><thead><tr><th>高效</th><th>抽象</th></tr></thead><tbody><tr><td>强大</td><td>简单</td></tr><tr><td>灵活</td><td>安全</td></tr></tbody></table><p>这是在系统设计上的三个矛盾点.</p><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>OS提供了许多特性和大量的服务, 他们之间趋向于交互, 有时候是奇怪的交互…</p><blockquote><p>两个功能, open 和 fork</p><p>使用open打开文件, 内核会返回文件的描述符 (<code>fd</code>).</p><p>使用fork新建当前进程的副本, 内核会返回新进程的进程号(<code>pid</code>).</p><p>但是在一个进程中先open一个文件, 再fork这个进程, 新的进程能否访问到之前的<code>fd</code>呢? Yes</p><p>这就是奇怪的交互</p></blockquote><h3 id="其他的点"><a href="#其他的点" class="headerlink" title="其他的点"></a>其他的点</h3><p>OS还必须要适应硬件的飞快发展, 以及各种不同的用途</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> 学习 </category>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识分布式事务</title>
      <link href="2021/03/22/%E5%88%9D%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>2021/03/22/%E5%88%9D%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="前置概念了解"><a href="#前置概念了解" class="headerlink" title="前置概念了解"></a>前置概念了解</h1><h2 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h2><p>事务是一组操作组成的一个操作序列, 当所有的操作都正常执行之后才能被全部提交. 只要有任意一次的操作失败了, 都将回滚所有的操作.</p><p>简单的说就是, 要么全部做完, 要么一个都别做.</p><h2 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h2><p>A(Atomicity)原子性</p><p>C(Consistency)一致性</p><p>I(Isolation)隔离性</p><p>D(Durability)持久性</p><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>CAP是2000年在PODC上提出的一个猜想. 2002年在MIT被证明. (证明是严格的证明, 讨论了在两个互相矛盾的请求到达彼此连接不通的两个不同的分布式节点)</p><ul><li>一致性（Consistency） </li><li>可用性（Availability）</li><li>分区容错性（Partition tolerance）</li></ul><h2 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h2><p>经过了长时间的实践, 人们发现通过CAP定理来维护事物的ACID特性需要付出很大的特性, 总结出来一套弱化的事务特性. 服务化中，更多的是提升 A 以及 P，在这个过程中不可避免的会降低对 C 的要求</p><ul><li>基本可用（Basically Available）：系统能够基本运行、一直提供服务。</li><li>软状态（Soft-state）：系统不要求一直保持强一致状态。</li><li>最终一致性（Eventual consistency）：系统需要在某一时刻后达到一致性要求。</li></ul><h1 id="分布式事务产生场景"><a href="#分布式事务产生场景" class="headerlink" title="分布式事务产生场景"></a>分布式事务产生场景</h1><p>随着互联网的发展, 简单的单机提供单一服务已经不能满足当下需求. </p><p>随着大数据时代来临, 庞大的数据量单一数据库已经不能完成很好的服务.</p><p>一个业务功能可能需要跨越多个服务和操作多个数据库. 分布式事务就是为了保证不同服务器之间的数据一致性.</p><h2 id="数据库分库"><a href="#数据库分库" class="headerlink" title="数据库分库"></a>数据库分库</h2><p>一个数据对应多个数据库</p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>一个业务跨越多个服务, 同时操作多个数据库</p><h1 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h1><h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>这是最简单的分布式事务解决方案, 也是其他解决方案的<strong>基础思维</strong>.</p><p>两个角色: 协调者(TM Transaction Manager), 参与者(RM Resource Manager)</p><h3 id="投票阶段"><a href="#投票阶段" class="headerlink" title="投票阶段"></a>投票阶段</h3><p>TM通知各RM准备提交事务.</p><ul><li>如果RM可以提交事务则给TM回复确定</li><li>如果RM无法提交则回复否定</li></ul><h3 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h3><p>TM根据所有RM的结果决定是提交还是回滚事务.</p><ul><li>如果全部为确认响应, 发起提交请求, RM收到请求后提交事务.</li><li>如果有否定响应, 则发起回滚请求, RM收到请求后回滚事务.</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>尽量高效的确保了数据的强一致性, 但不是100%一致.</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>TM故障: RM会一直阻塞, 事务资源被锁定, 无法继续完成事务操作和后续操作.</li><li>同步阻塞: 在等待TM回复的过程中一直占用公共资源, 导致第三方访问公共资源阻塞.</li><li>数据不一致: <ul><li>提交阶段TM发起提交请求后, 出现网络异常导致部分RM无法收到请求, 产生不一致数据.</li><li>如果协调者在第二阶段发送提交请求之后挂掉，而唯一接受到这条消息的参与者执行之后也挂掉了，即使协调者通过选举协议产生了新的协调者并通知其他参与者进行提交或回滚操作的话，都可能会与这个已经执行的参与者执行的操作不一样。</li></ul></li></ul><h2 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h2><h3 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h3><ol><li>引入超时机制.</li><li>新增一个阶段解决由于TM故障引起的阻塞问题.</li></ol><h3 id="第一阶段-CanCommit"><a href="#第一阶段-CanCommit" class="headerlink" title="第一阶段 CanCommit"></a>第一阶段 CanCommit</h3><p>等同于<strong>2PC</strong>的投票阶段</p><h3 id="第二阶段-PreCommit"><a href="#第二阶段-PreCommit" class="headerlink" title="第二阶段 PreCommit"></a>第二阶段 PreCommit</h3><p>TM判断各RM的响应轻快判断是否做预提交操作(PreCommit), 有两种可能:</p><ul><li><p>如果所有RM返回确认响应, 执行事务预提交</p><ol><li>向所有RM发送<code>PreCommit</code>请求</li><li>RM收到后将事务操作写入事务日志, 进行事务操作持久化.</li><li>成功完成了事务操作持久化后, 给TM确认响应, 等待下一步指令</li></ol></li><li><p>假如有RM返回了否认响应, 或者TM等待超时, 执行中断请求.</p><ol><li>TM向所有RM发送Abort请求.</li><li>RM收到Abort请求后执行事务中断.</li></ol></li></ul><h3 id="第三阶段-DoCommit"><a href="#第三阶段-DoCommit" class="headerlink" title="第三阶段 DoCommit"></a>第三阶段 DoCommit</h3><p>进行真正的事务提交</p><ul><li>执行提交<ol><li>TM收到所有RM来自PreCommit阶段的确认响应后,将状态更改为(预提交-&gt;)提交, 向所有RM发送确认提交请求.</li><li>RM收到确认提交请求后提交事务并释放事务资源.</li><li>RM完成后向TM发送确认请求.</li><li>TM收到所有RM在DoCommit阶段的确认后, 确认事务完成.</li></ol></li><li>中断事务<ol><li>TM没有收到所有RM来自PreCommit阶段的确认响应, (或是收到了RM的超时响应) (或者自身超时), 向所有的RM发送Abort请求.</li><li>RM收到Abort请求后, 根据事务操作日志中的记录回滚事务并释放事务资源.</li><li>RM完成回滚后, 向TM发送回滚完成确认响应.</li><li>TM收到RM的回滚确认后, 确认事务中断.</li></ol></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>已经解决了<ol><li>由于TM和某些RM挂掉导致的数据一致性问题</li><li>TM单点故障问题</li></ol></li><li>但是仍然存在<ol><li>在DoCommit阶段如果TM执行事务中断, 部分RM未能收到请求默认执行事务提交而导致的数据一致性问题.</li></ol></li></ul><p>可见2PC和3PC都无法保证100%数据一致性.</p><hr><p>简单写了一些, 明日再更.</p><p>先写作业，难顶</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> 算法 </category>
          
          <category> 分布式系统 </category>
          
          <category> 分布式事务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
